---
alwaysApply: false
---

# Reflect Phase - Level 2: Simple Enhancement

This document guides reflection for a Level 2 task. Keep it focused - a few sentences per section, one page max. The goal is to capture the key lesson, not write a retrospective.

## Step 1: Load Memory Bank Files

Read:
- `memory-bank/tasks.md`
- `memory-bank/projectbrief.md`
- `memory-bank/activeContext.md`
- `memory-bank/progress.md`

## Step 2: Verify Prerequisites

- Check `memory-bank/.qa-validation-status` exists and contains `PASS`
- If QA has not passed: ðŸ›‘ STOP - it does not make sense to reflect on work whose correctness has not been verified. Ask the operator for clarification, and wait for their instructions. You're done for now.

## Step 3: Review the Task

Walk through the task from start to finish, comparing what was planned against what actually happened:

- **Requirements vs Outcome**: Did the final implementation satisfy every requirement in the original plan? Were any requirements dropped, descoped, or reinterpreted during build? Were any added that weren't in the plan?

- **Plan Accuracy**: Was the implementation plan's sequence, file list, and scope correct? Did steps need reordering, splitting, or adding? Were the identified challenges the ones that actually materialized - or did surprises come from elsewhere?

- **Build & QA Observations**: What went smoothly during build? Where did you struggle or iterate? Did QA catch substantive issues, or was the build clean? If QA failed and required rework - what caused the gap between plan and implementation?

## Step 4: Extract Insights

Search hard for genuine insights - but do not reach. A forced insight pollutes the archive; an honest "nothing notable" is better than a manufactured lesson. The bar is: would this observation change how you approach a future task? If yes, write it down. If you're stretching to find something, leave the section empty.

When insights do surface, they can be raw observations ("the auth module's session middleware has implicit coupling to route guards - this bit us") or concrete recommendations ("next time, check session middleware first"). Both are valuable. Patterns may only become actionable after several reflections reveal the same friction point.

Categorize insights as:
- **Technical**: patterns discovered, gotchas in the codebase, library behaviors, architectural observations
- **Process**: workflow adjustments, estimation accuracy, phase-skipping opportunities, tooling improvements

## Step 5: Write Reflection Document

Create `memory-bank/reflection/reflection-<task-id>.md`:

~~~markdown
---
task_id: [task-id]
date: YYYY-MM-DD
complexity_level: 2
---

# Reflection: [Task Name]

## Summary

[1-2 sentence summary of what was built and whether it succeeded]

## Requirements vs Outcome

[Did we deliver what was asked? Any gaps or additions?]

## Plan Accuracy

[Was the plan right? What surprised us?]

## Build & QA Observations

[What went well, what was hard, what QA caught]

## Insights

### Technical
- [Concrete technical insight, or "Nothing notable"]

### Process
- [Concrete process insight, or "Nothing notable"]
~~~

## Step 6: Update Memory Bank

- Update `memory-bank/tasks.md`: mark Reflect phase complete
- Update `memory-bank/activeContext.md` with reflection outcome

## Step 7: Log Progress

Print a summary of the reflection according to the following format:

~~~markdown
# Reflect Result

## Summary

[1-2 sentence summary]

## Key Insights

- [Most important insight, or "Nothing notable - clean execution"]

## Next Steps

Run `/niko-archive` to create the archive document and finalize the current project.
~~~

## Step 8: Phase Transition

Reflection is a terminal node. Stop and wait for operator input.
